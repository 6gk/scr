#!/bin/sh
#  scr scr scr for scr

help() {
cat << EOF
scr (scr scr for scr)
Super CRappy SCReenshot SCRipt for Sound Cloud Rappers

examples
 # select an area and record at 30fps
 scr -c -e
 # record from display HDMI-0 at 60fps, use profile 'wnd', and save as file.mp4
 scr -c -mHDMI-0 -r60 -pwnd file.mp4

options
 screenshots
  -S     selection
	-P     primary display
	-G     custom geometry
 recording
	-s     save
	-e     select
	-m:    monitor
	-g:    custom geometry
  -r:    framerate
	-b:    bitrate (in MB)
	-p:    profile
	-a::   audio   (optional arg for changing pulse device)
	-c     don't confirm when starting
:  = arg is required, ex: '-r60'

variables:
  scr_dir & rec_dir
 scr_file & rec_file

dependencies
  xrandr
	boox / slop
	rofi / dmenu
 screenshots
  shotgun
	xclip
 recording
  pkill
  ffmpeg
	notify-send (optional, easy to replace/remove)
EOF
}

# clean environment
unset var confirm select geometry display rate profile audio nvenc

# pidfile & saving
pidf=/tmp/${0##*/}-pid
trap 'pkill -P $(cat $pidf)' TERM INT

# default values
: "${scr_dir:=$PWD}"  "${rec_dir:=$PWD}"  \
	"${scr_file:=$(date '+%Y-%m-%d_%H-%M-%S').png}" \
	"${rec_file:=$(date '+%Y-%m-%d_%H-%M-%S').mp4}"
output="$rec_dir/$rec_file"

# shorthand for checking whether a command exists
ex() { command -v "$1" >/dev/null 2>&1; }

men() {
	ex menu &&  { menu "$@"; return; }
	ex rofi &&  { rofi -dmenu "$@"; return; }
	ex dmenu && { dmenu -i "$@"; return; }
}

sel() {
	# allow parsing an arbitrary argument to format like 200x140+30+50
	# (the default) instead of separated by spaces
	ex boox && { boox ${1:-'%w %h %x %y'}; return; }
	ex slop && { slop ${1:--f '%w %h %x %y'}; return; }
}

audio() {
	# find default audio device
	[ "$1" ] || {
		pacmd="$(pacmd list-sources | grep -i -B 1 output)"
		dev="$(echo "$pacmd" | grep -m1 -i '\* index' | grep -o '[0-9]\+')"
	}
	audio="-f pulse -i ${1:-$dev}"
}

# list all monitors or a specific one
monitors() {
	# if an arg is provided, use that, else fall back to all monitors
	a=${1:- connected}
	# change definition of a 'word' so parsing is easier
	IFS='x+ '
	# primary is pretty much useless and makes it messier to parse, remove it
	xrandr --current | grep "$a" | sed 's/primary//' | while read -r line; do
		set -- $line
		# %-10s is for alignment
		# args 3-6 are the geometry in whxy, ex: 1920 1080 1366 0
		printf '%-10s%s\n' "$1" "$3 $4 $5 $6"
	done
}

# screenshots
screen() {
	shotgun -g "$1"  "${2:-$scr_dir/$scr_file}" &&
		xclip -sel clip -t image/png "${2:-$scr_dir/$scr_file}"
	exit
}

case $1 in
	-S)  screen "$(sel ' ')" "$2";;
	-G*) screen "${1#??}" "$2";;
	-P)  var=$2
		set -- $(monitors primary);  shift
		screen "$1x$2+$3+$4" "$var"
esac

while [ "$1" ]; do
case $1 in
	-h)  help; exit;;

	-s)  pkill -x "${0##*/}"; exit;;
	-g*) geometry=${1#??};;
	-m*) monitor=${1#??};;
	-r*) rate=${1#??};;
	-b*) bitrate="-b:v ${1#??}M";;
	-p*) profile=${1#??};;
	-a*) audio "${1#??}";;
	-c)  confirm=yes;;
	-e)  select=1;;
	-n)  nvenc=1;;
	*)   output="$1"; break
esac
shift
done

[ "$(pgrep -x "${0##*/}$" | wc -l)" -gt 2 ] &&
	echo "error: multiple instances running" && exit 1

# load profile
[ "$profile" ] && {
	dir=${XDG_CONFIG_HOME:=$HOME/.config}/scr
	mkdir -p "$dir"
	touch "$dir/$profile"
	. "$dir/$profile"
}

# if no methods are specified, prompt for one
[ "$geometry" ] || [ "$select" ] || [ "$monitor" ] || [ "$profilem" ] || {
	var=$(printf "%b\n" "$(monitors)\nselection" | menu)
	set -- $var
	case $var in
		selection) select=1;;
		# save the monitor name (for profiles)
		[A-Z]*) monitor=$1; shift;;
	esac
}

if [ "$geometry" ]; then
	IFS='x+ '
	set -- $geometry
	# allow for only specifying width and height
	set -- $1 $2 ${3:-0} ${4:-0}

# github.com/BanchouBoo/boox
elif [ "$select" ]; then
	set -- $(sel)

elif [ "$monitor" ]; then
	var=$(monitors "$monitor")
	IFS='x+ '
	set -- $var
	shift
fi

[ $# != 4 ] && echo "invalid method, exiting" && exit

# save profile
[ "$profile" ] && {
cat << EOF > "$dir/$profile"
audio=$audio
rate=$rate
nvenc=$nvenc
select=$select
profilem=1
set -- $1 $2 $3 $4
EOF
}

[ "$nvenc" ] || ex glxinfo && glxinfo | grep -q nvenc && nvenc='-c:v nvenc_h264'

[ "$confirm" ] || confirm=$(printf "yes\nno" | menu -p "start the recording?")

[ "$confirm" = yes ] && {
	notify-send -t 800 "recording started"
	echo "$$" > "$pidf"
	ffmpeg -y \
		-loglevel error  \
		$audio           \
		-f x11grab       \
		-draw_mouse 1    \
		-s "$1x$2"       \
		-i "$DISPLAY.0+$3,$4" \
		-r "${rate:-30}" \
		-pix_fmt yuv420p \
		$bitrate         \
		$nvenc           \
		-q:v 0           \
		"$output"

	rm "$pidf"
	notify-send -t 2000 "recording saved"

}
